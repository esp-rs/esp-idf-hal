<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="\brief          Try to write exactly ‘len’ application data bytes"><title>mbedtls_ssl_write in esp_idf_hal::sys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="esp_idf_hal" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0-nightly (8361aef0d 2025-01-14)" data-channel="nightly" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../esp_idf_hal/index.html">esp_<wbr>idf_<wbr>hal</a><span class="version">0.45.2</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In esp_<wbr>idf_<wbr>hal::<wbr>sys</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">esp_idf_hal</a>::<wbr><a href="index.html">sys</a></span><h1>Function <span class="fn">mbedtls_ssl_write</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/esp_idf_sys/home/runner/work/esp-idf-hal/esp-idf-hal/target/riscv32imc-esp-espidf/debug/build/esp-idf-sys-7bacc267eb742aef/out/bindings.rs.html#44184-44188">Source</a> </span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn mbedtls_ssl_write(
    ssl: *mut <a class="struct" href="struct.mbedtls_ssl_context.html" title="struct esp_idf_hal::sys::mbedtls_ssl_context">mbedtls_ssl_context</a>,
    buf: *const u8,
    len: usize,
) -&gt; i32</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>\brief          Try to write exactly ‘len’ application data bytes</p>
<p>\warning        This function will do partial writes in some cases. If the
return value is non-negative but less than length, the
function must be called again with updated arguments:
buf + ret, len - ret (if ret is the return value) until
it returns a value equal to the last ‘len’ argument.</p>
<p>\param ssl      SSL context
\param buf      buffer holding the data
\param len      how many bytes must be written</p>
<p>\return         The (non-negative) number of bytes actually written if
successful (may be less than \p len).
\return         #MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE
if the handshake is incomplete and waiting for data to
be available for reading from or writing to the underlying
transport - in this case you must call this function again
when the underlying transport is ready for the operation.
\return         #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous
operation is in progress (see
mbedtls_ssl_conf_async_private_cb()) - in this case you
must call this function again when the operation is ready.
\return         #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic
operation is in progress (see mbedtls_ecp_set_max_ops()) -
in this case you must call this function again to complete
the handshake when you’re done attending other tasks.
\return         #MBEDTLS_ERR_SSL_RECEIVED_NEW_SESSION_TICKET if a TLS 1.3
NewSessionTicket message has been received. See the
documentation of mbedtls_ssl_read() for more information
about this error code.
\return         #MBEDTLS_ERR_SSL_RECEIVED_EARLY_DATA if early data, as
defined in RFC 8446 (TLS 1.3 specification), has been
received as part of the handshake. This is server specific
and may occur only if the early data feature has been
enabled on server (see mbedtls_ssl_conf_early_data()
documentation). You must call mbedtls_ssl_read_early_data()
to read the early data before resuming the handshake.
\return         Another SSL error code - in this case you must stop using
the context (see below).</p>
<p>\warning        If this function returns something other than
a non-negative value,
#MBEDTLS_ERR_SSL_WANT_READ,
#MBEDTLS_ERR_SSL_WANT_WRITE,
#MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS,
#MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS or
#MBEDTLS_ERR_SSL_RECEIVED_NEW_SESSION_TICKET or
#MBEDTLS_ERR_SSL_RECEIVED_EARLY_DATA,
you must stop using the SSL context for reading or writing,
and either free it or call \c mbedtls_ssl_session_reset()
on it before re-using it for a new connection; the current
connection must be closed.</p>
<p>\note           When this function returns #MBEDTLS_ERR_SSL_WANT_WRITE/READ,
it must be called later with the <em>same</em> arguments,
until it returns a value greater than or equal to 0. When
the function returns #MBEDTLS_ERR_SSL_WANT_WRITE there may be
some partial data in the output buffer, however this is not
yet sent.</p>
<p>\note           If the requested length is greater than the maximum
fragment length (either the built-in limit or the one set
or negotiated with the peer), then:
- with TLS, less bytes than requested are written.
- with DTLS, MBEDTLS_ERR_SSL_BAD_INPUT_DATA is returned.
\c mbedtls_ssl_get_max_out_record_payload() may be used to
query the active maximum fragment length.</p>
<p>\note           Attempting to write 0 bytes will result in an empty TLS
application record being sent.</p>
</div></details></section></div></main></body></html>