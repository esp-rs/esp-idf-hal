<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Determines if pxTicksToWait ticks has passed since a time was captured using a call to vTaskSetTimeOutState().  The captured time includes the tick count and the number of times the tick count has overflowed."><title>xTaskCheckForTimeOut in esp_idf_hal::sys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="esp_idf_hal" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0-nightly (8361aef0d 2025-01-14)" data-channel="nightly" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../esp_idf_hal/index.html">esp_<wbr>idf_<wbr>hal</a><span class="version">0.45.2</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In esp_<wbr>idf_<wbr>hal::<wbr>sys</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">esp_idf_hal</a>::<wbr><a href="index.html">sys</a></span><h1>Function <span class="fn">xTaskCheckForTimeOut</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/esp_idf_sys/home/runner/work/esp-idf-hal/esp-idf-hal/target/riscv32imc-esp-espidf/debug/build/esp-idf-sys-7bacc267eb742aef/out/bindings.rs.html#13595-13598">Source</a> </span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn xTaskCheckForTimeOut(
    pxTimeOut: *mut <a class="struct" href="struct.xTIME_OUT.html" title="struct esp_idf_hal::sys::xTIME_OUT">xTIME_OUT</a>,
    pxTicksToWait: *mut u32,
) -&gt; i32</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Determines if pxTicksToWait ticks has passed since a time was captured
using a call to vTaskSetTimeOutState().  The captured time includes the tick
count and the number of times the tick count has overflowed.</p>
<p>@param pxTimeOut The time status as captured previously using
vTaskSetTimeOutState. If the timeout has not yet occurred, it is updated
to reflect the current time status.
@param pxTicksToWait The number of ticks to check for timeout i.e. if
pxTicksToWait ticks have passed since pxTimeOut was last updated (either by
vTaskSetTimeOutState() or xTaskCheckForTimeOut()), the timeout has occurred.
If the timeout has not occurred, pxTicksToWait is updated to reflect the
number of remaining ticks.</p>
<p>@return If timeout has occurred, pdTRUE is returned. Otherwise pdFALSE is
returned and pxTicksToWait is updated to reflect the number of remaining
ticks.</p>
<p>@see https://www.FreeRTOS.org/xTaskCheckForTimeOut.html</p>
<p>Example Usage:
@code{c}
// Driver library function used to receive uxWantedBytes from an Rx buffer
// that is filled by a UART interrupt. If there are not enough bytes in the
// Rx buffer then the task enters the Blocked state until it is notified that
// more data has been placed into the buffer. If there is still not enough
// data then the task re-enters the Blocked state, and xTaskCheckForTimeOut()
// is used to re-calculate the Block time to ensure the total amount of time
// spent in the Blocked state does not exceed MAX_TIME_TO_WAIT. This
// continues until either the buffer contains at least uxWantedBytes bytes,
// or the total amount of time spent in the Blocked state reaches
// MAX_TIME_TO_WAIT - at which point the task reads however many bytes are
// available up to a maximum of uxWantedBytes.</p>
<p>size_t xUART_Receive( uint8_t *pucBuffer, size_t uxWantedBytes )
{
size_t uxReceived = 0;
TickType_t xTicksToWait = MAX_TIME_TO_WAIT;
TimeOut_t xTimeOut;</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="comment">// Initialize xTimeOut.  This records the time at which this function
 // was entered.
 </span>vTaskSetTimeOutState( <span class="kw-2">&amp;</span>xTimeOut );

 <span class="comment">// Loop until the buffer contains the wanted number of bytes, or a
 // timeout occurs.
 </span><span class="kw">while</span>( UART_bytes_in_rx_buffer( pxUARTInstance ) &lt; uxWantedBytes )
 {
     <span class="comment">// The buffer didn't contain enough data so this task is going to
     // enter the Blocked state. Adjusting xTicksToWait to account for
     // any time that has been spent in the Blocked state within this
     // function so far to ensure the total amount of time spent in the
     // Blocked state does not exceed MAX_TIME_TO_WAIT.
     </span><span class="kw">if</span>( xTaskCheckForTimeOut( <span class="kw-2">&amp;</span>xTimeOut, <span class="kw-2">&amp;</span>xTicksToWait ) != pdFALSE )
     {
         <span class="comment">//Timed out before the wanted number of bytes were available,
         // exit the loop.
         </span><span class="kw">break</span>;
     }

     <span class="comment">// Wait for a maximum of xTicksToWait ticks to be notified that the
     // receive interrupt has placed more data into the buffer.
     </span>ulTaskNotifyTake( pdTRUE, xTicksToWait );
 }

 <span class="comment">// Attempt to read uxWantedBytes from the receive buffer into pucBuffer.
 // The actual number of bytes read (which might be less than
 // uxWantedBytes) is returned.
 </span>uxReceived = UART_read_from_receive_buffer( pxUARTInstance,
                                             pucBuffer,
                                             uxWantedBytes );

 <span class="kw">return </span>uxReceived;</code></pre></div>
<p>}
@endcode
\ingroup TaskCtrl</p>
</div></details></section></div></main></body></html>