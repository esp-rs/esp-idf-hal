<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Interrupt safe version of the API function that sends a stream of bytes to the stream buffer."><title>xStreamBufferSendFromISR in esp_idf_hal::sys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="esp_idf_hal" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0-nightly (8361aef0d 2025-01-14)" data-channel="nightly" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../esp_idf_hal/index.html">esp_<wbr>idf_<wbr>hal</a><span class="version">0.45.2</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In esp_<wbr>idf_<wbr>hal::<wbr>sys</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">esp_idf_hal</a>::<wbr><a href="index.html">sys</a></span><h1>Function <span class="fn">xStreamBufferSendFromISR</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/esp_idf_sys/home/runner/work/esp-idf-hal/esp-idf-hal/target/riscv32imc-esp-espidf/debug/build/esp-idf-sys-7bacc267eb742aef/out/bindings.rs.html#13941-13946">Source</a> </span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn xStreamBufferSendFromISR(
    xStreamBuffer: *mut <a class="struct" href="struct.StreamBufferDef_t.html" title="struct esp_idf_hal::sys::StreamBufferDef_t">StreamBufferDef_t</a>,
    pvTxData: *const c_void,
    xDataLengthBytes: usize,
    pxHigherPriorityTaskWoken: *mut i32,
) -&gt; usize</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Interrupt safe version of the API function that sends a stream of bytes to
the stream buffer.</p>
<p><em><strong>NOTE</strong></em>:  Uniquely among FreeRTOS objects, the stream buffer
implementation (so also the message buffer implementation, as message buffers
are built on top of stream buffers) assumes there is only one task or
interrupt that will write to the buffer (the writer), and only one task or
interrupt that will read from the buffer (the reader).  It is safe for the
writer and reader to be different tasks or interrupts, but, unlike other
FreeRTOS objects, it is not safe to have multiple different writers or
multiple different readers.  If there are to be multiple different writers
then the application writer must place each call to a writing API function
(such as xStreamBufferSend()) inside a critical section and set the send
block time to 0.  Likewise, if there are to be multiple different readers
then the application writer must place each call to a reading API function
(such as xStreamBufferReceive()) inside a critical section and set the receive
block time to 0.</p>
<p>Use xStreamBufferSend() to write to a stream buffer from a task.  Use
xStreamBufferSendFromISR() to write to a stream buffer from an interrupt
service routine (ISR).</p>
<p>@param xStreamBuffer The handle of the stream buffer to which a stream is
being sent.</p>
<p>@param pvTxData A pointer to the data that is to be copied into the stream
buffer.</p>
<p>@param xDataLengthBytes The maximum number of bytes to copy from pvTxData
into the stream buffer.</p>
<p>@param pxHigherPriorityTaskWoken  It is possible that a stream buffer will
have a task blocked on it waiting for data.  Calling
xStreamBufferSendFromISR() can make data available, and so cause a task that
was waiting for data to leave the Blocked state.  If calling
xStreamBufferSendFromISR() causes a task to leave the Blocked state, and the
unblocked task has a priority higher than the currently executing task (the
task that was interrupted), then, internally, xStreamBufferSendFromISR()
will set *pxHigherPriorityTaskWoken to pdTRUE.  If
xStreamBufferSendFromISR() sets this value to pdTRUE, then normally a
context switch should be performed before the interrupt is exited.  This will
ensure that the interrupt returns directly to the highest priority Ready
state task.  *pxHigherPriorityTaskWoken should be set to pdFALSE before it
is passed into the function.  See the example code below for an example.</p>
<p>@return The number of bytes actually written to the stream buffer, which will
be less than xDataLengthBytes if the stream buffer didn’t have enough free
space for all the bytes to be written.</p>
<p>Example use:
@code{c}
// A stream buffer that has already been created.
StreamBufferHandle_t xStreamBuffer;</p>
<p>void vAnInterruptServiceRoutine( void )
{
size_t xBytesSent;
char *pcStringToSend = “String to send”;
BaseType_t xHigherPriorityTaskWoken = pdFALSE; // Initialised to pdFALSE.</p>
<p>// Attempt to send the string to the stream buffer.
xBytesSent = xStreamBufferSendFromISR( xStreamBuffer,
( void * ) pcStringToSend,
strlen( pcStringToSend ),
&amp;xHigherPriorityTaskWoken );</p>
<p>if( xBytesSent != strlen( pcStringToSend ) )
{
// There was not enough free space in the stream buffer for the entire
// string to be written, ut xBytesSent bytes were written.
}</p>
<p>// If xHigherPriorityTaskWoken was set to pdTRUE inside
// xStreamBufferSendFromISR() then a task that has a priority above the
// priority of the currently executing task was unblocked and a context
// switch should be performed to ensure the ISR returns to the unblocked
// task.  In most FreeRTOS ports this is done by simply passing
// xHigherPriorityTaskWoken into portYIELD_FROM_ISR(), which will test the
// variables value, and perform the context switch if necessary.  Check the
// documentation for the port in use for port specific instructions.
portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
@endcode
\ingroup StreamBufferManagement</p>
</div></details></section></div></main></body></html>