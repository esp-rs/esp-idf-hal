<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="\brief          Perform the SSL handshake"><title>mbedtls_ssl_handshake in esp_idf_hal::sys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="esp_idf_hal" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0-nightly (8361aef0d 2025-01-14)" data-channel="nightly" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../esp_idf_hal/index.html">esp_<wbr>idf_<wbr>hal</a><span class="version">0.45.2</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In esp_<wbr>idf_<wbr>hal::<wbr>sys</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">esp_idf_hal</a>::<wbr><a href="index.html">sys</a></span><h1>Function <span class="fn">mbedtls_ssl_handshake</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/esp_idf_sys/home/runner/work/esp-idf-hal/esp-idf-hal/target/riscv32imc-esp-espidf/debug/build/esp-idf-sys-7bacc267eb742aef/out/bindings.rs.html#44164">Source</a> </span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn mbedtls_ssl_handshake(
    ssl: *mut <a class="struct" href="struct.mbedtls_ssl_context.html" title="struct esp_idf_hal::sys::mbedtls_ssl_context">mbedtls_ssl_context</a>,
) -&gt; i32</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>\brief          Perform the SSL handshake</p>
<p>\param ssl      SSL context</p>
<p>\return         \c 0 if successful.
\return         #MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE
if the handshake is incomplete and waiting for data to
be available for reading from or writing to the underlying
transport - in this case you must call this function again
when the underlying transport is ready for the operation.
\return         #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous
operation is in progress (see
mbedtls_ssl_conf_async_private_cb()) - in this case you
must call this function again when the operation is ready.
\return         #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic
operation is in progress (see mbedtls_ecp_set_max_ops()) -
in this case you must call this function again to complete
the handshake when youâ€™re done attending other tasks.
\return         #MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED if DTLS is in use
and the client did not demonstrate reachability yet - in
this case you must stop using the context (see below).
\return         #MBEDTLS_ERR_SSL_RECEIVED_NEW_SESSION_TICKET if a TLS 1.3
NewSessionTicket message has been received. See the
documentation of mbedtls_ssl_read() for more information
about this error code.
\return         #MBEDTLS_ERR_SSL_RECEIVED_EARLY_DATA if early data, as
defined in RFC 8446 (TLS 1.3 specification), has been
received as part of the handshake. This is server specific
and may occur only if the early data feature has been
enabled on server (see mbedtls_ssl_conf_early_data()
documentation). You must call mbedtls_ssl_read_early_data()
to read the early data before resuming the handshake.
\return         Another SSL error code - in this case you must stop using
the context (see below).</p>
<p>\warning        If this function returns something other than
\c 0,
#MBEDTLS_ERR_SSL_WANT_READ,
#MBEDTLS_ERR_SSL_WANT_WRITE,
#MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or
#MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS or
#MBEDTLS_ERR_SSL_RECEIVED_NEW_SESSION_TICKET or
#MBEDTLS_ERR_SSL_RECEIVED_EARLY_DATA,
you must stop using the SSL context for reading or writing,
and either free it or call \c mbedtls_ssl_session_reset()
on it before re-using it for a new connection; the current
connection must be closed.</p>
<p>\note           If DTLS is in use, then you may choose to handle
#MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED specially for logging
purposes, as it is an expected return value rather than an
actual error, but you still need to reset/free the context.</p>
<p>\note           Remarks regarding event-driven DTLS:
If the function returns #MBEDTLS_ERR_SSL_WANT_READ, no datagram
from the underlying transport layer is currently being processed,
and it is safe to idle until the timer or the underlying transport
signal a new event. This is not true for a successful handshake,
in which case the datagram of the underlying transport that is
currently being processed might or might not contain further
DTLS records.</p>
<p>\note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
subsystem must have been initialized by calling
psa_crypto_init() before calling this function.
Otherwise, the handshake may call psa_crypto_init()
if a negotiation involving TLS 1.3 takes place (this may
be the case even if TLS 1.3 is offered but eventually
not selected).</p>
</div></details></section></div></main></body></html>