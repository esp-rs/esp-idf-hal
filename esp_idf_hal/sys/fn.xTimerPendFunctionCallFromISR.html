<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Used from application interrupt service routines to defer the execution of a function to the RTOS daemon task (the timer service task, hence this function is implemented in timers.c and is prefixed with ‘Timer’)."><title>xTimerPendFunctionCallFromISR in esp_idf_hal::sys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="esp_idf_hal" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0-nightly (8361aef0d 2025-01-14)" data-channel="nightly" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../esp_idf_hal/index.html">esp_<wbr>idf_<wbr>hal</a><span class="version">0.45.2</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In esp_<wbr>idf_<wbr>hal::<wbr>sys</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">esp_idf_hal</a>::<wbr><a href="index.html">sys</a></span><h1>Function <span class="fn">xTimerPendFunctionCallFromISR</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/esp_idf_sys/home/runner/work/esp-idf-hal/esp-idf-hal/target/riscv32imc-esp-espidf/debug/build/esp-idf-sys-7bacc267eb742aef/out/bindings.rs.html#14087-14092">Source</a> </span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn xTimerPendFunctionCallFromISR(
    xFunctionToPend: Option&lt;unsafe extern &quot;C&quot; fn(_: *mut c_void, _: u32)&gt;,
    pvParameter1: *mut c_void,
    ulParameter2: u32,
    pxHigherPriorityTaskWoken: *mut i32,
) -&gt; i32</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Used from application interrupt service routines to defer the execution of a
function to the RTOS daemon task (the timer service task, hence this function
is implemented in timers.c and is prefixed with ‘Timer’).</p>
<p>Ideally an interrupt service routine (ISR) is kept as short as possible, but
sometimes an ISR either has a lot of processing to do, or needs to perform
processing that is not deterministic.  In these cases
xTimerPendFunctionCallFromISR() can be used to defer processing of a function
to the RTOS daemon task.</p>
<p>A mechanism is provided that allows the interrupt to return directly to the
task that will subsequently execute the pended callback function.  This
allows the callback function to execute contiguously in time with the
interrupt - just as if the callback had executed in the interrupt itself.</p>
<p>@param xFunctionToPend The function to execute from the timer service/
daemon task.  The function must conform to the PendedFunction_t
prototype.</p>
<p>@param pvParameter1 The value of the callback function’s first parameter.
The parameter has a void * type to allow it to be used to pass any type.
For example, unsigned longs can be cast to a void *, or the void * can be
used to point to a structure.</p>
<p>@param ulParameter2 The value of the callback function’s second parameter.</p>
<p>@param pxHigherPriorityTaskWoken As mentioned above, calling this function
will result in a message being sent to the timer daemon task.  If the
priority of the timer daemon task (which is set using
configTIMER_TASK_PRIORITY in FreeRTOSConfig.h) is higher than the priority of
the currently running task (the task the interrupt interrupted) then
*pxHigherPriorityTaskWoken will be set to pdTRUE within
xTimerPendFunctionCallFromISR(), indicating that a context switch should be
requested before the interrupt exits.  For that reason
*pxHigherPriorityTaskWoken must be initialised to pdFALSE.  See the
example code below.</p>
<p>@return pdPASS is returned if the message was successfully sent to the
timer daemon task, otherwise pdFALSE is returned.</p>
<p>Example usage:
@verbatim</p>
<p>// The callback function that will execute in the context of the daemon task.
// Note callback functions must all use this same prototype.
void vProcessInterface( void *pvParameter1, uint32_t ulParameter2 )
{
BaseType_t xInterfaceToService;</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="comment">// The interface that requires servicing is passed in the second
 // parameter.  The first parameter is not used in this case.
 </span>xInterfaceToService = ( BaseType_t ) ulParameter2;

 <span class="comment">// ...Perform the processing here...</span></code></pre></div>
<p>}</p>
<p>// An ISR that receives data packets from multiple interfaces
void vAnISR( void )
{
BaseType_t xInterfaceToService, xHigherPriorityTaskWoken;</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="comment">// Query the hardware to determine which interface needs processing.
 </span>xInterfaceToService = prvCheckInterfaces();

 <span class="comment">// The actual processing is to be deferred to a task.  Request the
 // vProcessInterface() callback function is executed, passing in the
 // number of the interface that needs processing.  The interface to
 // service is passed in the second parameter.  The first parameter is
 // not used in this case.
 </span>xHigherPriorityTaskWoken = pdFALSE;
 xTimerPendFunctionCallFromISR( vProcessInterface, NULL, ( uint32_t ) xInterfaceToService, <span class="kw-2">&amp;</span>xHigherPriorityTaskWoken );

 <span class="comment">// If xHigherPriorityTaskWoken is now set to pdTRUE then a context
 // switch should be requested.  The macro used is port specific and will
 // be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to
 // the documentation page for the port being used.
 </span>portYIELD_FROM_ISR( xHigherPriorityTaskWoken );</code></pre></div>
<p>}
@endverbatim</p>
</div></details></section></div></main></body></html>