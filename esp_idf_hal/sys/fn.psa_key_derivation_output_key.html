<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Derive a key from an ongoing key derivation operation."><title>psa_key_derivation_output_key in esp_idf_hal::sys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="esp_idf_hal" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0-nightly (8361aef0d 2025-01-14)" data-channel="nightly" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../esp_idf_hal/index.html">esp_<wbr>idf_<wbr>hal</a><span class="version">0.45.2</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In esp_<wbr>idf_<wbr>hal::<wbr>sys</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">esp_idf_hal</a>::<wbr><a href="index.html">sys</a></span><h1>Function <span class="fn">psa_key_derivation_output_key</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/esp_idf_sys/home/runner/work/esp-idf-hal/esp-idf-hal/target/riscv32imc-esp-espidf/debug/build/esp-idf-sys-7bacc267eb742aef/out/bindings.rs.html#37695-37699">Source</a> </span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn psa_key_derivation_output_key(
    attributes: *const <a class="struct" href="struct.psa_key_attributes_s.html" title="struct esp_idf_hal::sys::psa_key_attributes_s">psa_key_attributes_s</a>,
    operation: *mut <a class="struct" href="struct.psa_key_derivation_s.html" title="struct esp_idf_hal::sys::psa_key_derivation_s">psa_key_derivation_s</a>,
    key: *mut u32,
) -&gt; i32</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Derive a key from an ongoing key derivation operation.</p>
<p>This function calculates output bytes from a key derivation algorithm
and uses those bytes to generate a key deterministically.
The key’s location, usage policy, type and size are taken from
\p attributes.</p>
<p>If you view the key derivation’s output as a stream of bytes, this
function destructively reads as many bytes as required from the
stream.
The operation’s capacity decreases by the number of bytes read.</p>
<p>If this function returns an error status other than
#PSA_ERROR_INSUFFICIENT_DATA, the operation enters an error
state and must be aborted by calling psa_key_derivation_abort().</p>
<p>How much output is produced and consumed from the operation, and how
the key is derived, depends on the key type and on the key size
(denoted \c bits below):</p>
<ul>
<li>
<p>For key types for which the key is an arbitrary sequence of bytes
of a given size, this function is functionally equivalent to
calling #psa_key_derivation_output_bytes
and passing the resulting output to #psa_import_key.
However, this function has a security benefit:
if the implementation provides an isolation boundary then
the key material is not exposed outside the isolation boundary.
As a consequence, for these key types, this function always consumes
exactly (\c bits / 8) bytes from the operation.
The following key types defined in this specification follow this scheme:</p>
<ul>
<li>#PSA_KEY_TYPE_AES;</li>
<li>#PSA_KEY_TYPE_ARIA;</li>
<li>#PSA_KEY_TYPE_CAMELLIA;</li>
<li>#PSA_KEY_TYPE_DERIVE;</li>
<li>#PSA_KEY_TYPE_HMAC;</li>
<li>#PSA_KEY_TYPE_PASSWORD_HASH.</li>
</ul>
</li>
<li>
<p>For ECC keys on a Montgomery elliptic curve
(#PSA_KEY_TYPE_ECC_KEY_PAIR(\c curve) where \c curve designates a
Montgomery curve), this function always draws a byte string whose
length is determined by the curve, and sets the mandatory bits
accordingly. That is:</p>
<ul>
<li>Curve25519 (#PSA_ECC_FAMILY_MONTGOMERY, 255 bits): draw a 32-byte
string and process it as specified in RFC 7748 §5.</li>
<li>Curve448 (#PSA_ECC_FAMILY_MONTGOMERY, 448 bits): draw a 56-byte
string and process it as specified in RFC 7748 §5.</li>
</ul>
</li>
<li>
<p>For key types for which the key is represented by a single sequence of
\c bits bits with constraints as to which bit sequences are acceptable,
this function draws a byte string of length (\c bits / 8) bytes rounded
up to the nearest whole number of bytes. If the resulting byte string
is acceptable, it becomes the key, otherwise the drawn bytes are discarded.
This process is repeated until an acceptable byte string is drawn.
The byte string drawn from the operation is interpreted as specified
for the output produced by psa_export_key().
The following key types defined in this specification follow this scheme:</p>
<ul>
<li>#PSA_KEY_TYPE_DES.
Force-set the parity bits, but discard forbidden weak keys.
For 2-key and 3-key triple-DES, the three keys are generated
successively (for example, for 3-key triple-DES,
if the first 8 bytes specify a weak key and the next 8 bytes do not,
discard the first 8 bytes, use the next 8 bytes as the first key,
and continue reading output from the operation to derive the other
two keys).</li>
<li>Finite-field Diffie-Hellman keys (#PSA_KEY_TYPE_DH_KEY_PAIR(\c group)
where \c group designates any Diffie-Hellman group) and
ECC keys on a Weierstrass elliptic curve
(#PSA_KEY_TYPE_ECC_KEY_PAIR(\c curve) where \c curve designates a
Weierstrass curve).
For these key types, interpret the byte string as integer
in big-endian order. Discard it if it is not in the range
[0, <em>N</em> - 2] where <em>N</em> is the boundary of the private key domain
(the prime <em>p</em> for Diffie-Hellman, the subprime <em>q</em> for DSA,
or the order of the curve’s base point for ECC).
Add 1 to the resulting integer and use this as the private key <em>x</em>.
This method allows compliance to NIST standards, specifically
the methods titled “key-pair generation by testing candidates”
in NIST SP 800-56A §5.6.1.1.4 for Diffie-Hellman,
in FIPS 186-4 §B.1.2 for DSA, and
in NIST SP 800-56A §5.6.1.2.2 or
FIPS 186-4 §B.4.2 for elliptic curve keys.</li>
</ul>
</li>
<li>
<p>For other key types, including #PSA_KEY_TYPE_RSA_KEY_PAIR,
the way in which the operation output is consumed is
implementation-defined.</p>
</li>
</ul>
<p>In all cases, the data that is read is discarded from the operation.
The operation’s capacity is decreased by the number of bytes read.</p>
<p>For algorithms that take an input step #PSA_KEY_DERIVATION_INPUT_SECRET,
the input to that step must be provided with psa_key_derivation_input_key().
Future versions of this specification may include additional restrictions
on the derived key based on the attributes and strength of the secret key.</p>
<p>\note This function is equivalent to calling
psa_key_derivation_output_key_custom()
with the custom production parameters #PSA_CUSTOM_KEY_PARAMETERS_INIT
and <code>custom_data_length == 0</code> (i.e. <code>custom_data</code> is empty).</p>
<p>\param[in] attributes    The attributes for the new key.
If the key type to be created is
#PSA_KEY_TYPE_PASSWORD_HASH then the algorithm in
the policy must be the same as in the current
operation.
\param[in,out] operation The key derivation operation object to read from.
\param[out] key          On success, an identifier for the newly created
key. For persistent keys, this is the key
identifier defined in \p attributes.
\c 0 on failure.</p>
<p>\retval #PSA_SUCCESS
Success.
If the key is persistent, the key material and the key’s metadata
have been saved to persistent storage.
\retval #PSA_ERROR_ALREADY_EXISTS
This is an attempt to create a persistent key, and there is
already a persistent key with the given identifier.
\retval #PSA_ERROR_INSUFFICIENT_DATA
There was not enough data to create the desired key.
Note that in this case, no output is written to the output buffer.
The operation’s capacity is set to 0, thus subsequent calls to
this function will not succeed, even with a smaller output buffer.
\retval #PSA_ERROR_NOT_SUPPORTED
The key type or key size is not supported, either by the
implementation in general or in this particular location.
\retval #PSA_ERROR_INVALID_ARGUMENT
The provided key attributes are not valid for the operation.
\retval #PSA_ERROR_NOT_PERMITTED
The #PSA_KEY_DERIVATION_INPUT_SECRET or
#PSA_KEY_DERIVATION_INPUT_PASSWORD input was not provided through a
key; or one of the inputs was a key whose policy didn’t allow
#PSA_KEY_USAGE_DERIVE.
\retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
\retval #PSA_ERROR_INSUFFICIENT_STORAGE \emptydescription
\retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
\retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
\retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
\retval #PSA_ERROR_DATA_INVALID \emptydescription
\retval #PSA_ERROR_DATA_CORRUPT \emptydescription
\retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
\retval #PSA_ERROR_BAD_STATE
The operation state is not valid (it must be active and completed
all required input steps), or the library has not been previously
initialized by psa_crypto_init().
It is implementation-dependent whether a failure to initialize
results in this error code.</p>
</div></details></section></div></main></body></html>