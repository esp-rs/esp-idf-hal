<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="\brief           This function computes the ECDSA signature and writes it to a buffer, in a restartable way."><title>mbedtls_ecdsa_write_signature_restartable in esp_idf_sys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="esp_idf_sys" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0-nightly (8361aef0d 2025-01-14)" data-channel="nightly" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../esp_idf_sys/index.html">esp_<wbr>idf_<wbr>sys</a><span class="version">0.36.1</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="index.html">esp_idf_sys</a></span><h1>Function <span class="fn">mbedtls_ecdsa_write_signature_restartable</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/esp_idf_sys/home/runner/work/esp-idf-hal/esp-idf-hal/target/riscv32imc-esp-espidf/debug/build/esp-idf-sys-7bacc267eb742aef/out/bindings.rs.html#37057-37074">Source</a> </span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn mbedtls_ecdsa_write_signature_restartable(
    ctx: *mut <a class="type" href="type.mbedtls_ecdsa_context.html" title="type esp_idf_sys::mbedtls_ecdsa_context">mbedtls_ecdsa_context</a>,
    md_alg: <a class="type" href="type.mbedtls_md_type_t.html" title="type esp_idf_sys::mbedtls_md_type_t">mbedtls_md_type_t</a>,
    hash: *const c_uchar,
    hlen: usize,
    sig: *mut c_uchar,
    sig_size: usize,
    slen: *mut usize,
    f_rng: Option&lt;unsafe extern &quot;C&quot; fn(arg1: *mut c_void, arg2: *mut c_uchar, arg3: usize) -&gt; c_int&gt;,
    p_rng: *mut c_void,
    rs_ctx: *mut <a class="type" href="type.mbedtls_ecdsa_restart_ctx.html" title="type esp_idf_sys::mbedtls_ecdsa_restart_ctx">mbedtls_ecdsa_restart_ctx</a>,
) -&gt; c_int</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>\brief           This function computes the ECDSA signature and writes it
to a buffer, in a restartable way.</p>
<p>\see             \c mbedtls_ecdsa_write_signature()</p>
<p>\note            This function is like \c mbedtls_ecdsa_write_signature()
but it can return early and restart according to the limit
set with \c mbedtls_ecp_set_max_ops() to reduce blocking.</p>
<p>\param ctx       The ECDSA context to use. This must be initialized
and have a group and private key bound to it, for example
via mbedtls_ecdsa_genkey() or mbedtls_ecdsa_from_keypair().
\param md_alg    The message digest that was used to hash the message.
\param hash      The message hash to be signed. This must be a readable
buffer of length \p hlen Bytes.
\param hlen      The length of the hash \p hash in Bytes.
\param sig       The buffer to which to write the signature. This must be a
writable buffer of length at least twice as large as the
size of the curve used, plus 9. For example, 73 Bytes if
a 256-bit curve is used. A buffer length of
#MBEDTLS_ECDSA_MAX_LEN is always safe.
\param sig_size  The size of the \p sig buffer in bytes.
\param slen      The address at which to store the actual length of
the signature written. Must not be \c NULL.
\param f_rng     The RNG function. This must not be \c NULL if
#MBEDTLS_ECDSA_DETERMINISTIC is unset. Otherwise,
it is unused and may be set to \c NULL.
\param p_rng     The RNG context to be passed to \p f_rng. This may be
\c NULL if \p f_rng is \c NULL or doesnâ€™t use a context.
\param rs_ctx    The restart context to use. This may be \c NULL to disable
restarting. If it is not \c NULL, it must point to an
initialized restart context.</p>
<p>\return          \c 0 on success.
\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
operations was reached: see \c mbedtls_ecp_set_max_ops().
\return          Another \c MBEDTLS_ERR_ECP_XXX, \c MBEDTLS_ERR_MPI_XXX or
\c MBEDTLS_ERR_ASN1_XXX error code on failure.</p>
</div></details></section></div></main></body></html>